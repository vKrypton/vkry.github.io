{"meta":{"title":"vkry的杂物堆","subtitle":"记录点滴进步","description":"一个平平无奇的WordPress站点","author":"vkry","url":"https://blogger.vkry.xyz"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"about/index.html","permalink":"https://blogger.vkry.xyz/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"bangumi/index.html","permalink":"https://blogger.vkry.xyz/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"donate/index.html","permalink":"https://blogger.vkry.xyz/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"client/index.html","permalink":"https://blogger.vkry.xyz/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"comment/index.html","permalink":"https://blogger.vkry.xyz/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"https://blogger.vkry.xyz/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"links/index.html","permalink":"https://blogger.vkry.xyz/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2021-02-20T14:18:51.827Z","comments":false,"path":"music/index.html","permalink":"https://blogger.vkry.xyz/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"https://blogger.vkry.xyz/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"tags/index.html","permalink":"https://blogger.vkry.xyz/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://blogger.vkry.xyz/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"https://blogger.vkry.xyz/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"centOS7安装selenium","slug":"centOS7安装selenium","date":"2021-02-25T01:22:52.000Z","updated":"2021-02-25T01:27:49.158Z","comments":true,"path":"2021/02/25/centOS7安装selenium/","link":"","permalink":"https://blogger.vkry.xyz/2021/02/25/centOS7安装selenium/","excerpt":"","text":"centOS7安装selenium 一、安装Chrome yum install https://dl.google.com/linux/direct/google-chrome-stable_current_x86_64.rpm 二、安装ChromeDriver google-chrome --version #查看chrome版本 mkdir /root/chromedriver #找个地方放wget的文件，之后会删除 cd /root/chromedriver wget http://npm.taobao.org/mirrors/chromedriver/88.0.4324.96/chromedriver_linux64.zip unzip chromedriver_linux64.zip cp chromedriver /usr/bin/ 三、安装selenium pip install selenium pip install requests 四、测试 1.百度首页的响应 from selenium import webdriver # binary_location = &#39;/usr/bin/google-chrome&#39; # chrome_driver_binary= &#39;/usr/bin/chromedriver&#39; # import os options = webdriver.ChromeOptions() options.add_argument(&#39;--headless&#39;) #无头启动，无窗口加载 options.add_argument(&#39;--no-sandbox&#39;)#解决DevToolsActivePort文件不存在的报错 # options.add_argument(&#39;window-size=1920x3000&#39;) #指定浏览器分辨率 options.add_argument(&#39;--disable-dev-shm-usage&#39;) options.add_argument(&#39;--disable-gpu&#39;) #不开启gpu加速 options.add_argument(&#39;--hide-scrollbars&#39;) #隐藏滚动条, 应对一些特殊页面 options.add_argument(&#39;blink-settings=imagesEnabled=false&#39;) #不加载图片, 提升速度 # os.environ[&quot;webdriver.chrome.driver&quot;] = &#39;/usr/bin/chromedriver&#39; brower = webdriver.Chrome(executable_path = &quot;/usr/bin/chromedriver&quot;, options = options) brower.get(&quot;http://www.baidu.com&quot;) brower.close() print(brower.page_source)","categories":[{"name":"技术","slug":"技术","permalink":"https://blogger.vkry.xyz/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://blogger.vkry.xyz/categories/技术/"}]},{"title":"Spring源码环境搭建","slug":"Spring源码环境搭建","date":"2021-02-25T01:22:52.000Z","updated":"2021-02-25T01:27:04.111Z","comments":true,"path":"2021/02/25/Spring源码环境搭建/","link":"","permalink":"https://blogger.vkry.xyz/2021/02/25/Spring源码环境搭建/","excerpt":"","text":"Spring源码环境搭建一、下载源码有两种方式： 1.到github手动下载解压 2.复制上面的SSH地址去idea等工具的git里面clone出来 二、安装Gradle下载地址：Gradle官网下载（只需要下载bin即可） 得到的压缩包gradle-6.7.1-bin.zip解压到合适位置，配置PATH、GRADLE_HOME、GRADLE_USER_HOME（后两个不清楚有没有用到，应该是不配也行）。 1.手动指定Gradle地址（每个项目都要设置一下）如图，IDEA版本为2020.2 2.把压缩包保存到IDEA自动下载的位置，替换掉同名.part文件具体是上面设置的General settings -&gt; Gradle user home目录下的wrapper\\dists\\gradle-6.7.1-bin\\bwlcbys1h7rz3272sye1xwiv6，压缩包放进去就可以了，重启IDEA。 3.修改gradle-wrapper.properties路径在gradle/wrapper/gradle-wrapper.properties，地址是压缩包路径 distributionUrl=file:///D:/ToolKit/Gradle/gradle-6.7.1-bin.zip 三、编译1.手动编译： 2.IDEA自动编译 此步骤十分漫长，光下载依赖等待了近40分钟（最后还失败了）。 解决：修改项目根目录下的build.gradle文件的repositories repositories { maven{ url &#39;https://maven.aliyun.com/repository/public&#39;} mavenCentral() mavenLocal() maven { url &quot;https://repo.spring.io/libs-spring-framework-build&quot; } } 速度有一定提升，还是需要相当长的时间。","categories":[{"name":"技术","slug":"技术","permalink":"https://blogger.vkry.xyz/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://blogger.vkry.xyz/categories/技术/"}]},{"title":"aop学习","slug":"aop学习","date":"2021-02-25T01:22:52.000Z","updated":"2021-02-25T01:30:18.197Z","comments":true,"path":"2021/02/25/aop学习/","link":"","permalink":"https://blogger.vkry.xyz/2021/02/25/aop学习/","excerpt":"","text":"aop学习1、动态代理java有三种动态代理方式： 1.jdk自带Proxyjava.lang.reflect.Proxy的newProxyInstance方法 public class InvocationHandlerProxy implements InvocationHandler { private MyService service; public void setService(MyService service) { this.service = service; } public Object getProxy() { return Proxy.newProxyInstance(this.getClass().getClassLoader(), service.getClass().getInterfaces(), this); } public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // do something before method being invoked; System.out.println(method.getName() + &quot; will be called!&quot;); Object result = method.invoke(service, args); ////注意此处invoke方法中要有service，说明调用的是service中的方法，否则会出NullPoint System.out.println(method.getName() + &quot;has been called, result is &quot; + result); // do something after method being called; return result; } } 2.cglib代理基于继承方式实现的，目标对象无实现接口时，只能以这种方式代理，性能较差，目标对象不能为final类，方法不能是static、final或private（无法继承就失效了） // cglib代理工厂 public class CglibProxyFactory implements MethodInterceptor { public CglibProxyFactory() { } /** * 1、代理对象；2、委托类方法；3、方法参数；4、代理方法的MethodProxy对象。 * * @param o * @param method * @param objects * @param methodProxy * @return * @throws Throwable */ @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { System.out.println(&quot;事务开始......&quot; + method.getName()); Object o1 = methodProxy.invokeSuper(o, objects); System.out.println(&quot;事务结束.......&quot; + method.getName()); return o1; } } // 使用cglib，其中net.sf.cglib.proxy.Enhancer类为增强类即原class的子类 public class CglibClient { public static void main(String[] args) { //在指定目录下生成动态代理类，我们可以反编译看一下里面到底是一些什么东西 System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;G:/proxy&quot;); CglibProxyFactory cglibProxy = new CglibProxyFactory(); //jdk需要提供接口，cglib需要是非私有类，且不能处理final关键字修饰的方法 Enhancer enhancer = new Enhancer(); //设置父类 enhancer.setSuperclass(UserDao.class); //设置回调对象 enhancer.setCallback(cglibProxy); UserDao proxy = (UserDao) enhancer.create(); proxy.save(); System.out.println(&quot;===1===&quot;); proxy.delete(); System.out.println(&quot;===2===&quot;); proxy.saveAndDelete(); } } 3.spring的aop编程，通常使用aspectj包 Aspect（切面）： Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。 Joint point（连接点）：表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等，它自身还可以嵌套其它 joint point。 Pointcut（切点）：表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。 Advice（增强）：Advice 定义了在 Pointcut 里面定义的程序点具体要做的操作，它通过 before、after 和 around 来区别是在每个 joint point 之前、之后还是代替执行的代码。 Target（目标对象）：织入 Advice 的目标对象.。 Weaving（织入）：将 Aspect 和其他对象连接起来, 并创建 Adviced object 的过程 a.基于xml文件的配置beans.xml: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;bean id=&quot;service&quot; class=&quot;com.vkry.aop.service.MyServiceImpl&quot;/&gt; &lt;bean id=&quot;before&quot; class=&quot;com.vkry.aop.advice.Before&quot;/&gt;&lt;!-- 该类实现了MethodBeforeAdvice接口 --&gt; &lt;bean id=&quot;after&quot; class=&quot;com.vkry.aop.advice.After&quot;/&gt;&lt;!-- 该类实现了AfterReturningAdvice接口 --&gt; &lt;aop:config&gt; &lt;!-- 1.第一个*是修饰即public private等，例：execution(public * *(..)) 2.匹配任意以set开头的方法，例：execution(* set*(..)) 3.匹配包及子包下任意类和方法，例：execution(* com.vkry..*.*(..))--&gt; &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* add(..))&quot;/&gt; &lt;aop:advisor id=&quot;bbb&quot; advice-ref=&quot;after&quot; pointcut-ref=&quot;point&quot;/&gt; &lt;aop:advisor advice-ref=&quot;before&quot; pointcut-ref=&quot;point&quot;/&gt; &lt;!-- aop:aspect使用需要单独写一个类，ref就是那个类的引用，后面的method是那个类里的方法名 &lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;&quot;&gt; &lt;aop:after method=&quot;bbb&quot; pointcut-ref=&quot;point&quot; /&gt; &lt;aop:before method=&quot;ccc&quot; pointcut=&quot;execution(* add(..))&quot; /&gt; &lt;aop:after-throwing method=&quot;ddd&quot; pointcut-ref=&quot;point&quot;/&gt; &lt;/aop:aspect&gt; --&gt; &lt;/aop:config&gt; &lt;/beans&gt; java代码调用测试： public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); MyService service = context.getBean(&quot;service&quot;, MyService.class); service.add(); } b.基于注解的AOPapplicationContext.xml开启aspect注解支持：&lt;aop:aspectj-autoproxy/&gt; @Aspect public class AnnotationAop { @Before(&quot;execution(* com.vkry.aop.service.*.*(..))&quot;) public void aaa() { System.out.println(&quot;===============Before(注解)===============&quot;); } @After(&quot;execution(* com.vkry.aop.service.*.*(..))&quot;) public void bbb() { System.out.println(&quot;===============After(注解)================&quot;); } } 注意：没有标注顺序的情况下，同时存在注解和xml配置的aop，则xml的优先级更高，即先出现xml配置的advice后出现注解的。","categories":[{"name":"技术","slug":"技术","permalink":"https://blogger.vkry.xyz/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://blogger.vkry.xyz/categories/技术/"}]},{"title":"V2Ray避坑填坑指南","slug":"V2Ray避坑填坑指南","date":"2021-02-25T01:22:52.000Z","updated":"2021-02-25T01:26:47.479Z","comments":true,"path":"2021/02/25/V2Ray避坑填坑指南/","link":"","permalink":"https://blogger.vkry.xyz/2021/02/25/V2Ray避坑填坑指南/","excerpt":"","text":"V2Ray避坑填坑指南第一部分 安装一、基础版本==服务器==v2ray一键安装脚本：bash &lt;(curl -s -L https://git.io/v2ray.sh) 在/etc/v2ray目录下修改配置文件config.json { &quot;inbounds&quot;: [{ &quot;port&quot;: 23581, &quot;protocol&quot;: &quot;vmess&quot;, &quot;settings&quot;: { &quot;clients&quot;: [ { &quot;id&quot;: &quot;ceb793e6-49cf-25d8-e4de-ae542e62748e&quot;, &quot;level&quot;: 1, &quot;alterId&quot;: 64 } ] } }], &quot;outbounds&quot;: [{ &quot;protocol&quot;: &quot;freedom&quot;, &quot;settings&quot;: {} },{ &quot;protocol&quot;: &quot;blackhole&quot;, &quot;settings&quot;: {}, &quot;tag&quot;: &quot;blocked&quot; }], &quot;routing&quot;: { &quot;rules&quot;: [ { &quot;type&quot;: &quot;field&quot;, &quot;ip&quot;: [&quot;geoip:private&quot;], &quot;outboundTag&quot;: &quot;blocked&quot; } ] } } 设置开机启动：systemctl enable v2ray 启动：systemctl start v2ray ==客户端==v2rayN.exe 添加VMess服务器，地址为服务器地址，端口、用户ID照上面json里面的填就OK了，要注意不要用不常用的端口，容易被ban端口（虽然我用的80端口也被ban了） 二、ws伪装版本==服务器==购买域名-&gt;记录值指向服务器-&gt;等待生效 安装certbot：pip install certbot 申请Let’s Encrypt安全证书：certbot certonly -d 域名1 -d 域名2 --preferred-challenges dns --manual --server https://acme-v02.api.letsencrypt.org/directory 定时任务，三个月更新一次证书：修改/etc/crontab 增加一行 0 0 1 */2 0 root systemctl stop nginx; /usr/local/bin/certbot renew; systemctl restart nginx 安装Nginx（centOS）：yum install -y epel-release &amp;&amp; yum install -y nginx 修改/etc/nginx/conf.d/目录下的default.conf： server { listen 80; server_name xxxxx; # 改成你的域名 rewrite ^(.*) https://$server_name$1 permanent; } server { listen 1234 ssl http2; # 1234为客户端v2rayN访问的地址 server_name xxxxx; charset utf-8; # ssl配置 ssl_protocols TLSv1.2 TLSv1.3; # tls 1.3要求nginx 1.13.0及以上版本 ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384; ssl_prefer_server_ciphers off; ssl_session_cache shared:SSL:10m; ssl_session_timeout 1d; ssl_session_tickets off; ssl_certificate xxxxx; # 改成你的证书地址 ssl_certificate_key xxxx; # 改成证书密钥文件地址 access_log /var/log/nginx/xxxx.access.log; error_log /var/log/nginx/xxx.error.log; root /usr/share/nginx/html; location / { index index.html; } location /awesomepath { # 与 V2Ray 配置中的 path 保持一致 proxy_redirect off; proxy_pass http://127.0.0.1:23456; # 假设v2ray的监听地址是23456 proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } 启动Nginx：systemctl restart nginx 修改v2ray目录下的config.json { &quot;log&quot;: { &quot;loglevel&quot;: &quot;warning&quot;, &quot;access&quot;: &quot;/var/log/v2ray/access.log&quot;, &quot;error&quot;: &quot;/var/log/v2ray/error.log&quot; }, &quot;inbounds&quot;: [{ &quot;port&quot;: 23456, &quot;protocol&quot;: &quot;vmess&quot;, &quot;settings&quot;: { &quot;clients&quot;: [ { &quot;id&quot;: &quot;xxxxx&quot;, # 可以使用/usr/bin/v2ray/v2ctl uuid生成 &quot;level&quot;: 1, &quot;alterId&quot;: 0 } ] }, &quot;streamSettings&quot;: { # 载体配置段，设置为websocket &quot;network&quot;: &quot;ws&quot;, &quot;wsSettings&quot;: { &quot;path&quot;: &quot;/awesomepath&quot; # 与nginx中的路径保持一致 } }, &quot;listen&quot;: &quot;127.0.0.1&quot; # 出于安全考虑，建议只接受本地链接 }], &quot;outbounds&quot;: [{ &quot;protocol&quot;: &quot;freedom&quot;, &quot;settings&quot;: {} },{ &quot;protocol&quot;: &quot;blackhole&quot;, &quot;settings&quot;: {}, &quot;tag&quot;: &quot;blocked&quot; }], &quot;routing&quot;: { &quot;rules&quot;: [ { &quot;type&quot;: &quot;field&quot;, &quot;ip&quot;: [&quot;geoip:private&quot;], &quot;outboundTag&quot;: &quot;blocked&quot; } ] } } 重启v2ray：systemctl restart v2ray ==客户端==照着config.json填就好了 第二部分 填坑 yum安装报错：yum由python2.7编写，系统修改了默认的python软链接指向了python3，需要修改两个文件： # vi /usr/bin/yum #!/usr/bin/python2.7 # vi /usr/libexec/urlgrabber-ext-down #!/usr/bin/python2.7 服务器安装了宝塔7.5.1，原先能用的v2ray不能用了 查看/usr/bin目录发现nginx指向了新安装的目录/www/server，而不是原来的/etc/nginx，只好将原来的配置迁移到新位置： （1）添加站点，把之前买的域名填上就行了 （2）设置里面的配置文件就是原来nginx的配置文件，默认只有80端口的，把需要的端口给填上 （3）有系统防火墙的，给端口放行","categories":[{"name":"技术","slug":"技术","permalink":"https://blogger.vkry.xyz/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://blogger.vkry.xyz/categories/技术/"}]},{"title":"java定时器","slug":"java定时器","date":"2021-02-25T01:22:52.000Z","updated":"2021-02-25T01:27:26.310Z","comments":true,"path":"2021/02/25/java定时器/","link":"","permalink":"https://blogger.vkry.xyz/2021/02/25/java定时器/","excerpt":"","text":"java定时器 最早的解决方法是java.utils提供的Timer和TimerTask类，继承TimerTask并实现其中的run方法，再用timer的schedule方法调用。 spring也集成了类似的timer工具包，可以使用其中ScheduleTimerTask、TimerFactoryBean在xml中配置一个与java.util一样的定时器 &lt;!--配置一个触发器 配置触发器的参数--&gt; &lt;bean id=&quot;scheduleRingTask&quot; class=&quot;org.springframework.scheduling.timer.ScheduledTimerTask&quot;&gt; &lt;property name=&quot;delay&quot; value=&quot;3000&quot;&gt;&lt;/property&gt; &lt;!--第一次延迟3秒的时间--&gt; &lt;property name=&quot;period&quot; value=&quot;3000&quot;&gt;&lt;/property&gt; &lt;!--每隔3秒的时间执行一次--&gt; &lt;property name=&quot;timerTask&quot; ref=&quot;ringTask&quot;&gt;&lt;/property&gt; &lt;!--制定触发的类--&gt; &lt;/bean&gt; &lt;!-- 总调度,用于启动定时器 --&gt; &lt;bean id=&quot;timerFactory&quot; class=&quot;org.springframework.scheduling.timer.TimerFactoryBean&quot;&gt; &lt;property name=&quot;scheduledTimerTasks&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;scheduleRingTask&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean quartz是基于spring的更强大的定时器，具体到年月日时分秒的任务也可以执行了。 使用到的类有： JobDetailBean（任务类，其中的jobClass需要继承QuartzJobBean，不继承可以用MethodInvokingJobDetailFactoryBean，可以直接指定类的方法） SimpleTriggerBean（或CronTriggerBean，触发器，定义何时启动） SchedulerFactoryBean（总调度，启动器，里面有一个list） 基于注解时一个@Scheduled就完事了","categories":[{"name":"技术","slug":"技术","permalink":"https://blogger.vkry.xyz/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://blogger.vkry.xyz/categories/技术/"}]},{"title":"java并发学习","slug":"并发学习","date":"2021-02-25T01:22:52.000Z","updated":"2021-02-25T01:26:29.103Z","comments":true,"path":"2021/02/25/并发学习/","link":"","permalink":"https://blogger.vkry.xyz/2021/02/25/并发学习/","excerpt":"","text":"JUC-java.util.concurrent包-并发学习 一、并发安全数据结构 1.传统Collections工具类下转化普通ArrayList HashSet HashMap 2.JUC下CopyOnWriteArrayList\\CopyOnWriteArraySet\\ConcurrentHashMap 二、Callable接口 与Runnable的区别： ​ 1.有返回值 ​ 2.能抛出异常 ​ 3.需要实现的方法不叫run()，叫call() 调用需要用FutureTask类接收 FutureTask是Runnable 的实现类(RunnableFuture接口继承了Runnable+Future两个接口，FutureTask实现了RunnableFuture） 因此能被Thread的构造方法接收 public FutureTask(Callable&lt;V&gt; callable) { if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable } public FutureTask(Runnable runnable, V result) { this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable } 使用： public class CallabelDemo { public static void main(String[] args) throws ExecutionException, InterruptedException { MyTask my = new MyTask(); FutureTask&lt;String&gt; future = new FutureTask&lt;&gt;(my); for (int i = 0; i &lt; 9; i++) { new Thread(future, String.valueOf(i)).start(); System.out.println(&quot;Thread&quot; + i + &quot; said: &quot; + future.get()); } } } class MyTask implements Callable&lt;String&gt; { @Override public String call() throws Exception { System.out.println(Thread.currentThread().getName()+&quot; call()&quot;); TimeUnit.SECONDS.sleep(1); return &quot;Hello, world&quot;; } } 三、并发辅助类 1.CountDownLatch 给定初始值，多线程调用countDown方法，调用到达初始值个数时，main方法里的await释放，程序往下运行 public static void main(String[] args) throws InterruptedException { CountDownLatch cdl = new CountDownLatch(5); for(int i = 0; i &lt; 5; i++) { new Thread(() -&gt; { System.out.println(&quot;Thread &quot; + Thread.currentThread().getName() + &quot; finished&quot;); cdl.countDown(); }, String.valueOf(i)).start(); } cdl.await(); System.out.println(&quot;Threads are all closed&quot;); } 2.CyclicBarrier 几乎与CountDownLatch相反，各个线程调用CyclicBarrier的await方法，到一定次数后，执行CyclicBarrier构造方法里定义的Runnable方法 public static void main(String[] args) { CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; { System.out.println(&quot;召唤神龙成功&quot;); }); for (int i = 0; i &lt; 7; i++) { final int id = i; new Thread( () -&gt; { System.out.println(&quot;激活龙珠&quot; + id); try { cyclicBarrier.await(); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } System.out.println(&quot;我想……&quot;); }, String.valueOf(i)).start(); } } 3.Semaphore 信号量，获取和释放分别对应acquire和release方法，acquire有acquireUninterruptibly的拓展方法，使用acquireUninterruptibly时，下例中的a.interrupt()不起作用。对于多信号量控制时，一定要注意release方法的无参调用只能释放一个信号量，例： public static void main(String[] args) throws InterruptedException { Semaphore semaphore = new Semaphore(3, true); // System.out.println(&quot;信号量总数：&quot; + semaphore.availablePermits()); // for (int i = 0; i &lt; 5; i++) { // new Thread(() -&gt; { // try { // semaphore.acquireUninterruptibly(2); // System.out.println(Thread.currentThread().getName() + &quot; 获取了2信号量&quot;); // TimeUnit.SECONDS.sleep(1); // System.out.println(Thread.currentThread().getName() + &quot; 睡了一秒，释放1信号量&quot;); // semaphore.release(1); // TimeUnit.SECONDS.sleep(2); // System.out.println(Thread.currentThread().getName() + &quot; 睡了两秒，释放1信号量&quot;); // semaphore.release(1); // } catch (InterruptedException e) { // e.printStackTrace(); // } // }, String.valueOf(i)).start(); // } Thread a = new Thread(()-&gt;{ try { semaphore.acquire(3); TimeUnit.SECONDS.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } finally { semaphore.release(); System.out.println(&quot;a信号量已释放&quot;); } }); a.start(); TimeUnit.SECONDS.sleep(1); a.interrupt(); new Thread(()-&gt;{ try { // 事实上，程序无法运行到这里，信号量未被全部释放。 semaphore.acquire(3); System.out.println(&quot;第二线程得到了信号量，release方法空参默认释放所有占据的信号量&quot;); } catch (InterruptedException e) { e.printStackTrace(); } finally { semaphore.release(); } }).start(); } 四、读写锁 ReentrantReadWriteLock 独占锁（写锁）：一次只能有一个线程写 共享锁（读锁）：可以由多个线程同时使用，但也不能不加读锁，因为读时不能写，否则会脏读。 五、流式并行 class C implements Calculator { @Override public long calc() { // rangeClosed是闭区间，range是开区间，含左边不含右边， // parallel()开启并发 // reduce不给初始值0返回的是LognOptional类型的对象 return LongStream.rangeClosed(1L,10_0000_0000L).parallel().reduce(0, Long::sum); } } 六、Volatile Volatile是Java提供的轻量级同步机制 1.保证可见性 2.不保证原子性 例子：多线程对变量a++，无法保证最后总数是对的 3.禁止指令重排 七、JMM JMM是Java内存模型，是一种约定 一些同步的约定： 1.线程解锁前，必须把共享变量立刻刷回主存（线程使用主存里的变量是在自己的工作内存里拷贝了一份，后续操作的是拷贝） 2.线程加锁前，必须读取主存中的最新值到工作内存 3.加锁解锁必须是同一把锁 8种操作： lock(锁定)：作用于主内存，它把一个变量标记为一条线程独占状态； read(读取)：作用于主内存，它把变量值从主内存传送到线程的工作内存中，以便随后的load动作使用； load(载入)：作用于工作内存，它把read操作的值放入工作内存中的变量副本中； use(使用)：作用于工作内存，它把工作内存中的值传递给执行引擎，每当虚拟机遇到一个需要使用这个变量的指令时候，将会执行这个动作； assign(赋值)：作用于工作内存，它把从执行引擎获取的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的指令时候，执行该操作； store(存储)：作用于工作内存，它把工作内存中的一个变量传送给主内存中，以备随后的write操作使用； write(写入)：作用于主内存，它把store传送值放到主内存中的变量中。 unlock(解锁)：作用于主内存，它将一个处于锁定状态的变量释放出来，释放后的变量才能够被其他线程锁定； 八、单例模式 饿汉式：直接new 对象存在类的静态变量里，这既是优点也是缺点，优点是快，编写方便，缺点是占内存 懒汉式：getInstance先判断类里的静态变量是否为null，是则new对象，否则直接返回，改良了饿汉式占空间的缺点，但在高并发下会创建出多个实例，单例被破坏 DCL懒汉式：解决高并发时普通懒汉式可能出现的风险，写法是判空后加一层同步代码块，再进行一次判空，之后才new对象 –为什么静态变量要加volatile？new对象的操作不是原子性操作，可能发生指令重排，当指令重排发生时，new对象尚未完成，仅仅注册了一个空壳，别的线程就拿去用了，这样会产生错误，因此加上volatile禁止指令重排。 –为什么要判空两次？–因为可能有多个线程经过了判空，在同步代码块外等待锁被释放，一旦释放而不进行二次判空，这些线程又会重新new对象出来，单例被破坏。 –可不可以把第一次判空去掉？–不可以，没有第一次判空会使所有执行getInstance方法的线程都进同步代码块，不能快速返回 验证代码：main方法开二十条线程同时获取单例类的实例，进入同步代码块就+1，创建出对象+1 public class SingleDemo { public static void main(String[] args) throws InterruptedException { CyclicBarrier cb = new CyclicBarrier(20, () -&gt; { System.out.println(&quot;共执行同步代码块&quot;+SingleLazy.getLockCount+&quot;次&quot;); System.out.println(&quot;共创建对象&quot;+SingleLazy.instanceNum+&quot;次&quot;); }); for (int i = 0; i &lt; 20; i++) { new Thread(()-&gt;{ SingleLazy.getInstance(); try { cb.await(); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } }).start(); } } } class SingleLazy { private volatile static SingleLazy instance; public static int getLockCount = 0; public static int instanceNum = 0; private SingleLazy() {} public static SingleLazy getInstance() { if (instance == null) { synchronized (SingleLazy.class) { getLockCount++; if (instance == null) { instanceNum++; instance = new SingleLazy(); } } } return instance; } } ​ 结果： 静态内部类： 静态内部类里面保留一个实例，基本和饿汉式一致 –反射通过xx.class.getDeclaredConstructor(null);con.setAccessible(true);cons.newInstance();获取单例对象 –单例类的构造方法判空，并抛出异常 –两个实例均通过反射获取，则单例类里面变量都是空，判空失效 –单例类私有属性对构造方法加限制，比如加一个flag的boolean属性，构造方法里面判断不为true就return –通过xx.class.getDeclaredField(“flag”).setAccessible(true);field.set(instance,true);修改属性 enum枚举： public enum CheckType { NO_PASS(0, &quot;未通过&quot;), PASS(1, &quot;通过&quot;); private int key; private String text; private CheckType(int key, String text) { this.key = key; this.text = text; } public int getKey() { return key; } public String getText() { return text; } private static HashMap&lt;Integer,CheckType&gt; map = new HashMap&lt;Integer,CheckType&gt;(); static { for(CheckType d : CheckType.values()){ map.put(d.key, d); } } public static CheckType parse(Integer index) { if(map.containsKey(index)){ return map.get(index); } return null; } } – 仍然有漏洞，无法阻止反序列化时产生的新对象！需要覆写Object类的readResolve()方法！ private Object readResolve() throws ObjectStreamException { return INSTANCE; } 九、死锁排查 jps定位进程号 jps -l jstack查看进程信息jstack 进程号 锁专辑： 乐观锁： 悲观锁： 重量级锁： 轻量锁： 偏向锁：","categories":[{"name":"技术","slug":"技术","permalink":"https://blogger.vkry.xyz/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://blogger.vkry.xyz/categories/技术/"}]},{"title":"循环依赖理解","slug":"循环依赖理解","date":"2021-02-25T01:22:52.000Z","updated":"2021-02-25T01:28:08.840Z","comments":true,"path":"2021/02/25/循环依赖理解/","link":"","permalink":"https://blogger.vkry.xyz/2021/02/25/循环依赖理解/","excerpt":"","text":"循环依赖理解： AbstractBeanFactory类的getSingleton是循环依赖最重要的方法总结：首先spring会去单例池根据名字获取bean，单例池就是在DefaultSingletonBeanRegistry类中维护的singletonObjects是ConcurrentHashMapdoGetBean方法是创建和获取bean通用的方法，比如循环依赖这种特殊情况，创建A{B b;}和B{A a;}时，各自实例化都需要对方的bean对象A和B在建立时，这里调用getSingleton得到的结果为null，目的是判断实例是否已创建下面还有一个getSingleton的重载方法，在那里真正进行了bean创建。会在一个set集合中记录当前请求的bean正在被创建。如果递归调用回来发现正在创建中就说明循环依赖了 回答循环依赖问题一定要答到的点：1.spring能解决的范畴：（1）先明确循环依赖的场景：a.构造器中的循环依赖;b.field属性的循环依赖spring只能解决属性的循环依赖，对于构造器的，会抛出BeanCurrentlyInCreationException异常（2）spring只解决scope为singleton的循环依赖，对于prototype类型的抛出BeanCurrentlyInCreationException异常2.spring实例化一个对象底层用的是反射，需要推断构造方法等复杂过程，因此在拿到实例的时候并不是一个完整的bean，需要让这个对象去参与spring的生命周期才能完善为一个bean，其中有一步是判断容器是否允许循环依赖，如果允许循环依赖，spring会把这个对象临时存到一个Map里（singletonFactories）这个map和上面提到的单例池以及earlySingletonObjects并称为三级缓存（1）singletonFactories ： 单例对象工厂的cache（2）earlySingletonObjects ：提前暴光的单例对象的Cache（3）singletonObjects：单例对象的cache区别有：singletonObjects里面存放的是创建好的bean，类型是ConcurrentHashMapearlySingletonObjects和singletonFactories里存放临时对象（不完整的bean），类型是HashMap单例池就是为了getBean存在的，另两个是为了方便循环引用 取消循环依赖的方法： 1.改源码 2.获取到spring的上下文后先将context中的一个名叫allowCircularReferences的属性设置为false，之后再手动去register当前的类对象再refresh","categories":[{"name":"技术","slug":"技术","permalink":"https://blogger.vkry.xyz/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://blogger.vkry.xyz/categories/技术/"}]},{"title":"爬虫学习积累","slug":"爬虫学习积累","date":"2021-02-25T01:22:52.000Z","updated":"2021-02-25T01:28:23.947Z","comments":true,"path":"2021/02/25/爬虫学习积累/","link":"","permalink":"https://blogger.vkry.xyz/2021/02/25/爬虫学习积累/","excerpt":"","text":"爬虫学习积累 一、python框架/库包 urllib2/requests –收发请求 re(正则)/bs4(BeatifulSoup) –简化XML/HTML解析 Scrapy 一些简易demo #urllib from bs4 import BeautifulSoup import urllib2 url = &#39;http://reeoo.com&#39; request = urllib2.Request(url) response = urllib2.urlopen(request, timeout=20) content = response.read() soup = BeautifulSoup(content, &#39;html.parser&#39;) #附：一些积累经验 常用Header headers = { &#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&#39; } 一、Bilibili爬取 def dec(x):#BV号转换成AV号 alphabet = &#39;fZodR9XQDSUm21yCkr6zBqiveYah8bt4xsWpHnJE7jL5VG3guMTKNPAwcF&#39; r = 0 for i, v in enumerate([11, 10, 3, 8, 4, 6]): r += alphabet.find(x[v]) * 58**i return (r - 0x2_0840_07c0) ^ 0x0a93_b324 评论 采集地址：https://api.bilibili.com/x/v2/reply?type=1&amp;pn=1&amp;oid=56760346&amp;sort=2 GET 其中pn是评论的页数oid是av号的数字部分，bv号暂时没了解和oid有什么关系 规则：访问该地址获取的是JSON数据，设获取到的JSON对象为obj，则 comment_num = obj.data.page.count # 楼层数 total_num = obj.data.page.account # 含楼中楼的总评论数 uid = obj.data.replies[x].mid # 评论者id-单条 uname = obj.data.replies[x].member.uname # 评论者名称-单条 reply = obj.data.replies[x].content.message # 主楼评论内容-单条 subreply = obj.data.replies[x].content.replies # null或数组；同reply，可做subreply[x].mid获取用户id、subreply[x].content.message获取内容 BV转通用oid/cid 采集地址：https://api.bilibili.com/x/player/pagelist?bvid=BV1vy4y1i7bS&amp;jsonp=jsonp GET 规则：获取访问链接返回JSON对象obj的obj[“data”][0][“cid”] 弹幕 采集地址：https://api.bilibili.com/x/v1/dm/list.so?oid={} GET","categories":[{"name":"技术","slug":"技术","permalink":"https://blogger.vkry.xyz/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://blogger.vkry.xyz/categories/技术/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-02-19T02:13:05.906Z","updated":"2021-02-19T02:13:05.906Z","comments":true,"path":"2021/02/19/hello-world/","link":"","permalink":"https://blogger.vkry.xyz/2021/02/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"https://blogger.vkry.xyz/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"https://blogger.vkry.xyz/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"https://blogger.vkry.xyz/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://blogger.vkry.xyz/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://blogger.vkry.xyz/categories/技术/"}]}]}